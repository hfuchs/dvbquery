#!/usr/bin/perl -w
# 2010-02-03, Created by H Fuchs <hagen.fuchs@physik.tu-dresden.de>
# The GPL applies; if this script breaks something, don't come running to me!
#
# Witz: Wenn die Anfrage nicht länger als 10 Tage her ist, nimm die Daten
# einfach aus dem Cache.  Noch cooler: Liefere immer aus dem Cache, aber
# starte einen thread, der nochmal kontrolliert.

use strict;
use utf8;
use open ':locale';  # Governs STD*, open(), readpipe(), ...
use LWP::Simple;   # TODO Either LWP *or* Mech!
use WWW::Mechanize 1.5;
use HTML::TreeBuilder;
use Encode;
use Getopt::Long;    # Able to take the same option multiple times.
use CGI qw/unescapeHTML/;
use feature qw/say switch/;
use URI;
use Try::Tiny;


# --- Globals
# TODO Read from config file
my $server_url = "http://widgets.vvo-online.de/abfahrtsmonitor/";
my $ort        = "Dresden";
my %config     = (  # TODO Put all config here.
    'want_to_chat' => 1,
    'debug'        => 0,
    # TODO Define default output-format here: Markdown or "chat".
);


# --- Main

# Command-line parsing
my ($from, $to, $time, @complex, $help);
GetOptions(
    'from:s'    => \$from,  # TODO Allow eg. 'Dresden, Hauptbahnhof'.
    'to:s'      => \$to,
    'at:s'      => \$time,  # TODO Change to departure, arrival
    'complex:s' => \@complex,
    'help'      => \$help,
);

display_help() if ($help);

# TODO No args?  Ask.  Better still, start interactive prompt.
# TODO Support user-definable abbreviations (eg 'NÖ', 'HB' etc).
if (@complex) {
    display_itinerary(sanitize_input(@complex));
} elsif ($from = sanitize_input($from)) {
    if ($to = sanitize_input($to)) {
        display_connections($from, $to); # TODO Pass time as well.
    } else {
        display_departure($from);
    }
} else {
    chat("Would it bother you very much telling me what it is you want?");
    display_help();
}


# --- Subroutines
sub display_itinerary {
    my (@plans) = @_;

    say foreach (@plans);

    #chat("What a journey!  Let's see...");
    # No chatting, this is serious business.
    $config{'want_to_chat'} = 0;

    foreach my $plan (@plans) {
        my @itinerary = parse_complex_plan($plan); # Array of hash refs

        foreach my $trip (@itinerary) {
            use Data::Dumper;
            say Dumper $trip;
            $time = $trip->{'time'}              if $trip->{'time'};
            $from = $trip->{'from'}->{'station'} if $trip->{'from'}->{'station'};
            $to   = $trip->{'to'}->{'station'}   if $trip->{'to'}->{'station'};
            display_connections($from, $to);
        }
    }
}

sub parse_complex_plan {
    # Parses strings like
    # 'hauptbahnhof;albertplatz;albertplatz,fiedlerstraße,9:00'
    # to produce an array like this:
    # @trips = (
    #    {
    #      'from' => { 'town', 'station' },
    #      'to'   => { 'town', 'station' },
    #      'time' => [time_string, eg: 20:00],
    #      'type' => [string, departure ("ab") or arrival ("an")]
    #    },
    #    { 'from' => ...
    # );
    #
    #
    # TODO Later (more advanced): Parse
    # 'Dresden, hauptbahnhof@9:00;Weinböhla,weinböhla HP' and
    # 'From: haupbahnhof@9:00 TO: albertplatz to: fiedlerstraße, 9:00' or even
    # 'Von: hauptbahnhof, 9:00 nach: albertplatz von: fiedlerstraße, 17.00
    #  nach hauptbahnhof'!
    # TODO Define a test function, which one could paste into the terminal to
    # exercise all program paths.  Or: How do you test shit like this?
    my @records = split /;/, shift;
    my @trips;  # The complex datatype described above.

    for (my $i=0; $i < scalar(@records); $i=$i+2) {
        my %trip;

        # Odd records - departure specification
        my @fields = split /,/, $records[$i];

        use feature 'switch';  # TODO Preampleize!
        given (scalar(@fields)) {
            when (2) {
                $trip{'from'}->{'town'} = $fields[0];
                my ($station, $time) = split /@/, $fields[1];
                if ($time) {
                    $trip{'time'} = $time;
                    $trip{'type'} = 'ab';
                };
                $trip{'from'}->{'station'} = $station;
            }
            when (1) {
                my ($station, $time) = split /@/, $fields[0];
                if ($time) {
                    $trip{'time'} = $time;
                    $trip{'type'} = 'ab';
                };
                $trip{'from'}->{'station'} = $station;
            }
            default { die "What a dump."; }

        }

        # Even records - arrival specification
        # TODO Lots of redundant code
        @fields = split /,/, $records[$i+1];

        use feature 'switch';  # TODO Preampleize!
        given (scalar(@fields)) {
            when (2) {
                $trip{'to'}->{'town'} = $fields[0];
                my ($station, $time) = split /@/, $fields[1];
                # TODO if both $departure_time and $arrival_time are specified,
                # the later overrides the former.  Is this what you would expect?
                if ($time) {
                    $trip{'time'} = $time;
                    $trip{'type'} = 'an';
                };
                $trip{'to'}->{'station'} = $station;
            }
            when (1) {
                my ($station, $time) = split /@/, $fields[0];
                # TODO if both $departure_time and $arrival_time are specified,
                # the later overrides the former.  Is this what you would expect?
                if ($time) {
                    $trip{'time'} = $time;
                    $trip{'type'} = 'an';
                };
                $trip{'to'}->{'station'} = $station;
            }
            default { die "What a dump."; }
        }


        push @trips, \%trip;
    }

    return @trips;
}

sub display_connections {
    # TODO Direct output to Markdown would be nice.
    my ($from, $to) = @_;

    #chat("Travelling from '" . $from . "' to '" . $to . "', I see.");
    say("Travelling from '" . $from . "' to '" . $to . "', I see.\n");

    if (check_station_uniqueness($from, $to)) {

        # Now on to the real connection data.
        my $result = parse_connection_data(fetch_connection_data($from, $to));

        if (scalar(@$result) > 0) {
            # TODO witty chat here
            foreach my $ride (@$result) {
                foreach my $stop (@$ride) {
                    print $stop->{'time'}.' '.$stop->{'aban'}.' '.$stop->{'station'};
                    print " ($stop->{'line'})" if ($stop->{'line'});
                    if ($stop->{'note'}) {
                        print "\n\t" . $stop->{'note'};
                    }
                    print "\n";
                }
                print "\n";
            }
        } else {
            say "That's odd ... no connection results?";
        }
    }
    return 1;
}

sub parse_connection_data {
    # Note: You'll have to verify for yourself, whether all the fields are
    # actually defined.  TODO Or should I do this?
    my $tree = HTML::TreeBuilder->new_from_content(shift);
    my $result;

    # Find all "full trip" tables and parse each one.
    my @rides = $tree->look_down( '_tag' , 'table', 'class', 'full trip' );
    my $i = 0;  # Index of rides, to be used in $result
    foreach my $ride (@rides) {
        my @stops = $ride->look_down( '_tag', 'tr' );
        my $k = 0;  # Index of stops in each ride.
        foreach my $stop (@stops) {
            # Remove elements that add no information.
            my @bastards = $stop->look_down('_tag', 'ul', 'class',
                'linkliste');
            push @bastards, $stop->look_down('_tag', 'img');
            $_->delete foreach (@bastards);

            # Find the individual description elements.  Entries:
            #  - time
            #  - "ab"/"an"
            #  - station
            #  - additional information (Those are often quite tricky!)
            my @desc = $stop->look_down( '_tag', 'td' );
            $result->[$i]->[$k]->{'time'}    = $desc[0]->as_text;
            $result->[$i]->[$k]->{'aban'}    = $desc[1]->as_text;  # TODO Key name?
            $result->[$i]->[$k]->{'station'} = $desc[2]->as_text;

            # Parsing the badly-formatted info-string $desc[4]
            # TODO Linienänderungen!  ul class=changelist
            # TODO Überfahrhilfe!  </br>Überfahrhilfe
            # TODO Format of "Fußgänger"-entries is not quite cute.
            foreach my $info ($desc[4]->look_down('_tag','td')) {
                if (my $bold = $info->look_down('_tag','b')) {
                    my $line = $bold->as_text;
                    $line =~ s/^[^0-9]*([0-9]*)[^0-9]*$/$1/;
                    $result->[$i]->[$k]->{'line'} = $line;
                    $bold->delete;
                }
                $result->[$i]->[$k]->{'note'} = $info->as_text;
            }
            $k++;
        }
        $i++;
    }
    $tree->delete;

    return $result;
}

sub fetch_connection_data {
    # TODO $time still global
    my ($from, $to) = @_;

    # See HTML::Element for operations on the tree, HTML::TreeBuilder for
    # parsing information and WWW::Mechanize for general documentation.
    my $mech = new WWW::Mechanize;

    # TODO Zum Kotzen.
    my ($sec,$min,$hour,$day,$month,$year,,,) = localtime(time);
    $year = $year+1900;
    $time = "$hour:$min" unless ($time);

    $mech->get('http://dvb.de'); # TODO variable?
    my $page = $mech->submit_form(
        'with_fields' => {
            'vaform[datum]'     =>  "$day." . ++$month . ".$year",
            'vaform[startname]' =>  $from,
            'vaform[startort]'  =>  'Dresden',
            'vaform[zeit]'      =>  $time,
            'vaform[zeittyp]'   =>  'dep',
            'vaform[zielname]'  =>  $to,
            'vaform[zielort]'   =>  'Dresden',
        }
    );

    if ($mech->success) {
        return decode_utf8 $page->content
    } else {
        # TODO You should probably die or carp or something.
        say STDERR "Error: ", $mech->response->status_line;
    }
}

sub display_departure {
    my $station = shift;

    chat("So, you want to know everything about station '$station'?");

    if (check_station_uniqueness($station)) {

        # Now on to the real departure data.
        my $result = parse_departure_data(fetch_departure_data($station));

        if (scalar(@$result) > 0) {
            chat("Holmes!  Coaches leave in:");
            foreach my $entry (@$result) {
                print "  ". $entry->{'minutes'} . "\tminutes to " .
                $entry->{'destination'} . " (" .
                $entry->{'number'} . ")." . "\n";
            }
        } else {
            chat("My!  Nothing leaves from _there_.");
        }
    } # No else required here, right?

    return 1;
}

sub parse_departure_data {
    my $string = shift;
    my $result;

    if ($string =~ s/^\[(.*)\]$/$1/) {
        my $i = 0;
        while ($string =~ s/^,?\["(.*?)","(.*?)","(.*?)"\]//) {
            $result->[$i]->{'number'}      = $1;
            $result->[$i]->{'destination'} = $2;
            $result->[$i++]->{'minutes'}   = $3;
        }
        return $result
    } else {
        die "Unparseable."; # TODO: exception handling
    }
}

sub fetch_departure_data {
    my $station = shift;

    my $url = URI->new($server_url .
        "Abfahrten.do?ort=$ort&hst=$station&vz=20:00");
        # TODO Not sure about these.
        # +"&vm="+preferenceForKey('vmPrefChecked')
        # +"&lim="+preferenceForKey('listitemsPrefChecked'));
    return decode_utf8(unescapeHTML(get($url)))
        or die "TODO - I died!";
}

sub parse_station_data {
    my $string = shift;
    my $result;

    if ($string =~ s/^\[(.*)\]$/$1/) { # Removing outmost brackets.
        my $i = 0;
        while ($string =~ s/^,?\[\["(.*?)"\]\],\[\[(.*?)\]\]//) {
            $result->[$i]->{'ort'}        = $1;
            my @stations                  = split(/\],\[/, $2);
            map { s/^"(.*?)".*$/$1/ } @stations;
            $result->[$i++]->{'stations'} = \@stations;
        }
        return $result
    } else {
        die "Unparseable.";
    }
}

sub fetch_station_data {
    my $station = shift;
    # URL(decode_utf8)=plauen%20n%C3%B6thnitzer%20stra%C3%9Fe
    # URL(nothing)    =plauen%20n%C3%B6thnitzer%20stra%C3%9Fe
    # URL(to_latin)   =plauen%20n%F6thnitzer%20stra%DFe

    my $url  = URI->new($server_url . "Haltestelle.do?ort=$ort&hst=$station");
    try {
        my $page = get($url) or die "Network";
        $page = decode_utf8 CGI::unescapeHTML($page) or die "Fatal";
        return $page;
    } catch {
        when (/Network/) { die "Sorry, the DVB server is down.\n" }
        default          { die "Fatal" }
    }
}

sub check_station_uniqueness {
    # TODO Caching!  Learning!
    # TODO Inconsistent user interface, chat()s all over the place.
    my @stations = @_;

    foreach my $station (@stations) {
        my $result = parse_station_data(fetch_station_data($station));

        if (scalar(@{$result->[0]->{'stations'}}) > 1) {
            chat("But multiple stations match your request (silly bugger!):");
            say  "  $_" foreach (@{$result->[0]->{'stations'}});
            chat("Do try to be more specific next time, will you?");
            return '';
        }
    }

    return 1;
}

sub sanitize_input {
    # TODO Is that all as regards sanitization?
    if (scalar(@_) > 1) {
        return map { $_ = decode_utf8($_); } @_;
    } else {
        return decode_utf8(shift);
    }
}

sub display_help {
    # TODO Use POD.
    say "DVB query script";
    say "Usage:";
    say "  Display station info   -    dvb -f [station]";
    say "  Route planning         -    dvb -f [from] -t [to] [-a [at]]";
    say "  Complex route planning -    dvb -c [route specification]";
    say "\nComplex Route Specification:";
    say "  [from,to,at;from,to,at;...]";
    say "\nExamples:";
    say "  dvb -f albertplatz -t 'plauen nöthnitzer straße' -a '19:00'";
    say "  dvb -c 'albertplatz,hauptbahnhof,9:00;plauen nöthnitzer straße,albertplatz,19:00'";
    #say "----";
    #say "2010, Hagen Fuchs <hagen.fuchs@physik.tu-dresden.de>";
    exit -1;
}

sub D {
    say STDERR "Debug (@_)" if ($config{'debug'});
    return;
}

sub chat {
    # TODO More variety!  Say sth. different!
    say @_ if ($config{'want_to_chat'});
    return;
}

